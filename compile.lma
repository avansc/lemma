;;;
;; Just a na•ve translator at the moment...
;; TODO: Macros, namespaces, methods, etc.
;;       Try to get line numbers to match up in compiled code.
;;       Try to catch as many errors as possible before and at compile time.
;;;

(def format   lua/string.format)
(def concat   lua/table.concat)
(def unpack   lua/Seq.lib.unpack)
(def tostring lua/tostring)
(def type     lua/type)

;; Not exactly Clojure's mapcat, since this concat isn't exactly Clojure's
;; concat... return the string concatenation of a mapped seq
(defn mapcat [f @xs]
  (str (unpack (map f ,@xs))))

;; TODO: More specials: cond, macro
(def specials {
    :def (fn [xs]
           (let [ks (odds  xs)
                 vs (evens xs)]
             (mapcat (fn [k v]
                      (format "local %s = %s\n" (compile k) (compile v)))
                    ks
                    vs)))
     :fn  (fn [xs]
            (let [args (first xs)
                  body (rest  xs)]
              (let [funstuff ["function("
                              (lua/string.sub (mapcat
                                                (fn [arg]
                                                  (str (compile arg) ", "))
                                                args)
                                              1
                                              -3)
                              ")\n"
                              (unpack (map compile body))
                              "\nend"]]
                (lua/table.insert funstuff (- (length funstuff) 1) "return ")
                (concat funstuff))))})

;; Take an internal representation (e.g., from read()) and output Lua code
(defn compile [exp]
  (let [switch {
         :number     (fn [x] (format "%d " x))
         :string     (fn [x] (format "%q " x))
         :Symbol     (fn [x] (.string x))
         :boolean    (fn [x] (if x :true :false))
         :False      (fn [x] :false)
         :Nil        (fn [x] :nil)
         :Vector     (fn [x]
                       (str "Vector{ "
                            (mapcat (fn [y]
                                      (str (compile y) ", "))
                                    x)
                            "} "))
         ;; (I think there's a problem in cons for HashMap... thus the set!)
         :HashMap    (fn [x]
                       (def t [])
                       (for-each (fn [y]
                                   (lua/table.insert t (str "["
                                                            (compile (first y))
                                                            "] = "
                                                            (compile (second y))
                                                            ", ")))
                                  x)
                       (str "HashMap{ "
                            (unpack t)
                            "} "))
         ;; Could preserve order here if we don't defer to HashMap compilation
         :PreHashMap (fn [x]
                       (compile (lua/HashMap (unpack x))))
         ;; Needs to handle table lookups if first is not a special or function
         ;; -> add __call metamethods to all Lemma-generated tables
         :List       (fn [x]
                       ;(print (lua/tostring (first x)))
                       (let [f (specials (lua/tostring (first x)))]
                         (if f (f (rest x))
                               (str (compile (first x))
                                    "("
                                    (lua/string.sub
                                      (mapcat (fn [y]
                                                (str (compile y) ", "))
                                              (rest x))
                                      1
                                      -3)
                                    ")"))))}]
     (if (switch (type exp))
         ((switch (type exp)) exp)
         :nil)))

;; Compile one expression for testing
(lua/io.write "> ")
(print (compile (lua/read (lua/FileStream (lua/io.input)))))
