;; This will grow into part of Lemma's standard library.

;; A macro to make defining macros nicer...
(def defmacro
  (macro [name arglist @body]
    `(def ~name (macro ~arglist ~@body))))

;; A macro to make defining functions nicer...
(defmacro defn [name arglist @body]
  `(def ~name (fn ~arglist ~@body)))


;; do
(defmacro do [@body]
  `((fn [] ~@body)))


;; Implement the usual if expression
(defmacro if [p? a b]
  `(cond ~p? ~a true ~b))

;; And if's little sister, when
(defmacro when [p? @body]
  `(cond ~p? (do ~@body) true nil))



;; Just to save typing.
(defn second [s]
  (first (rest s)))

;; Get a list containing the elements of xs with odd-numbered indices
(defn odds [xs]
  (if (empty? xs)
      (seq xs)
      (cons (first xs) (odds (rest (rest xs))))))

;; Get a list containing the elements of xs with even-numbered indices
(defn evens [xs]
  (if (or (empty? xs) (= 1 (length xs)))
      (seq xs)
      (cons (first (rest xs)) (evens (rest (rest xs))))))



;; let
(defmacro let [bindings @body]
  `((fn ~(odds bindings) ~@body) ~@(evens bindings)))

;; like let, but allows recursion using recur
(defmacro loop [bindings @body]
  `(do
     (defn recur ~(odds bindings) ~@body)
     (recur ~@(evens bindings))))

;; it's a mix of if and let
;; creates a binding and evaluates the body if the binding is truthy
(defmacro let-if [binding @body]
  (let [var (first binding)
        val (second binding)]
    `((fn [~var] (when ~var ~@body)) ~val)))

;; like let, but sets all bindings to the result(s) of
;; the first expression in body
;; WARNING: you will get garbage values if not enough
;;          values are produced to bind all the variables
(defmacro let-values [bindings @body]
  `((fn ~bindings ~@(rest body)) ~(first body)))



;; Evaluate body n times
(defmacro times [n @body]
  `(do
     (defn once [i]
       (if (= i 2)
           (do ~@body)
           (do
             ~@body
             (once (- i 1)))))
     (once ~n)))



;; Generate predicates to test for each type
(let [types ["Vector" "HashMap" "List" "Symbol" "Macro" "Fexpr" "function"]]
  (for-each
    (fn [s]
      (let [name (lua/Symbol (str "lemma/" (.lower s) "?"))]
        (eval
          `(def ~name (fn [a]
             (= (lua/type a) ~s)))
          lua/env)))
    types))



;; A convenience macro for Lua interop
(defmacro defmethod [t-dot-f args @body]
  (if (not (vector? args))
    (lua/Error (str "defmethod: expected vector, got " (lua/tostring args) " : " (lua/type args)))
    `(defn ~t-dot-f [self ~@args] ~@body)))



;; Change namespaces
(defmacro ns [name]
  (if (symbol? name)
      `(lua/ns ~(.string name))
      (lua/Error (str "ns: expected symbol, got " (lua/tostring name) " : " (lua/type args)))))
