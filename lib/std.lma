;; This will grow into part of Lemma's standard library.

;; A macro to make defining macros nicer...
(def defmacro
  (macro (name arglist @body)
    `(def ~name (macro ~arglist ~@body))))

;; A macro to make defining functions nicer...
(defmacro defn (name arglist @body)
  `(def ~name (fn ~arglist ~@body)))


;; Implement the usual if expression
(defmacro if (p? a b)
  `(cond ~p? ~a #t ~b))


;; Get a list containing the elements of xs with odd-numbered indices
(defn odds (xs)
  (if (empty? xs)
      '()
      (cons (first xs) (odds (rest (rest xs))))))

;; Get a list containing the elements of xs with even-numbered indices
(defn evens (xs)
  (if (or (empty? xs) (= 1 (length xs)))
      '()
      (cons (first (rest xs)) (evens (rest (rest xs))))))


;; let
(defmacro let (bindings @body)
  `((fn (~@(odds bindings)) ~@body) ~@(evens bindings)))

;; do
(defmacro do (@body)
  `((fn () ~@body)))



;; like let, but sets all bindings to the result(s) of
;; the first expression in body
;; WARNING: you will get garbage values if not enough
;;          values are produced to bind all the variables
(defmacro let-values (bindings @body)
  `((fn (~@bindings) ~@(rest body)) ~(first body)))


;; This shouldn't be part of the core language, but some of
;; the test code still relies on it.
(defmacro times (n @body)
  `(do
     (defn once (i)
       (if (= i 2)
           (do ~@body)
           (do
             ~@body
             (once (- i 1)))))
     (once ~n)))
