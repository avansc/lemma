;; This will grow into part of Lemma's standard library.

;; A macro to make defining macros nicer...
(def defmacro
  (macro [name arglist @body]
    `(def ~name (macro ~arglist ~@body))))

;; A macro to make defining functions nicer...
(defmacro defn [name arglist @body]
  `(def ~name (fn ~arglist ~@body)))


;; Implement the usual if expression
(defmacro if [p? a b]
  `(cond ~p? ~a true ~b))

;; And if's little sister, when
(defmacro when [p? a]
  `(cond ~p? ~a true nil))


;; Get a list containing the elements of xs with odd-numbered indices
(defn odds [xs]
  (if (empty? xs)
      (seq xs)
      (cons (first xs) (odds (rest (rest xs))))))

;; Get a list containing the elements of xs with even-numbered indices
(defn evens [xs]
  (if (or (empty? xs) (= 1 (length xs)))
      (seq xs)
      (cons (first (rest xs)) (evens (rest (rest xs))))))


;; let
(defmacro let [bindings @body]
  `((fn [~@(odds bindings)] ~@body) ~@(evens bindings)))

;; do
(defmacro do [@body]
  `((fn [] ~@body)))



;; like let, but sets all bindings to the result(s) of
;; the first expression in body
;; WARNING: you will get garbage values if not enough
;;          values are produced to bind all the variables
(defmacro let-values [bindings @body]
  `((fn ~bindings ~@(rest body)) ~(first body)))


;; This shouldn't be part of the core language, but some of
;; the test code still relies on it.
(defmacro times [n @body]
  `(do
     (defn once [i]
       (if (= i 2)
           (do ~@body)
           (do
             ~@body
             (once (- i 1)))))
     (once ~n)))
     

(defn vector? [a]
  (= (lua/type a) "Vector"))

;; A convenience macro for Lua interop
(defmacro defmethod [t-dot-f args @body]
  (if (not (vector? args))
    (lua/Error (str "defmethod: expected vector, got " (lua/tostring args) " : " (lua/type args)))
    `(defn ~t-dot-f [self ~@args] ~@body)))
