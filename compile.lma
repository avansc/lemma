;;;
;; Just a na•ve translator at the moment...
;; TODO: Macros, namespaces, methods, etc.
;;       Try to get line numbers to match up in compiled code.
;;       Try to catch as many errors as possible before and at compile time.
;;;

(def format   lua/string.format)
(def concat   lua/table.concat)
(def unpack   lua/Seq.lib.unpack)
(def tostring lua/tostring)
(def type     lua/type)

;; Not exactly Clojure's mapcat, since this concat isn't exactly Clojure's
;; concat... return the string concatenation of a mapped seq
(defn mapcat [f @xs]
  (str (unpack (map f ~@xs))))

(defn c-eval [exp]
  ((lua/assert (lua/loadstring (str "local _env = lemma\n" (compile exp))))))

;; TODO: More specials: macro, ...
(def specials {
    :cond (fn [xs]
            (let [ks (odds  xs)
                  vs (evens xs)]
              (str "(function()\nlocal _env = lemma['local-env']()\n"
                "if (" (compile (first ks)) ") then\nreturn "
                     (compile (first vs))
                (mapcat (fn [k v]
                          (str "\nelseif (" (compile k) ") then\nreturn "
                            (compile v)))
                        (rest ks)
                        (rest vs))
                "\nend\nend)()\n")))
    :def  (fn [xs]
            (let [ks (odds  xs)
                  vs (evens xs)]
              (mapcat (fn [k v]
                       (format "local %s = %s\n" (compile k) (compile v)))
                     ks
                     vs)))
     :fn   (fn [xs]
             (let [args (first xs)
                   body (rest  xs)]
               (let [funstuff ["(function("
                               (lua/string.sub (mapcat
                                                 (fn [arg]
                                                   (str (.string arg) ", "))
                                                 args)
                                               1
                                               -3)
                               ")\nlocal _env = lemma['local-env']()\n"
                               (unpack (map compile body))
                               "\nend)"]]
                 (lua/table.insert funstuff (- (length funstuff) 1) "return ")
                 (concat funstuff))))})
;;;
;; Take an internal representation (e.g., from read()) and output Lua code
;;;
(defn compile [exp]
  (let [switch {
         :number     (fn [x] (format "%d" x))
         :string     (fn [x] (format "%q" x))
         ;; TODO: Handle namespaces, table members
         :Symbol     (fn [x] (str "_env[\""
                                  (.string x)
                                  "\"]"))
         :boolean    (fn [x] (if x :true :false))
         :False      (fn [x] :false)
         :Nil        (fn [x] :nil)
         :Vector     (fn [x]
                       (str "Vectorize{"
                            (mapcat (fn [y]
                                      (str (compile y) ", "))
                                    x)
                            "}"))
         ;; (I think there's a problem in cons for HashMap... thus the set!)
         :HashMap    (fn [x]
                       (def t [])
                       (for-each (fn [y]
                                   (lua/table.insert t (str "["
                                                            (compile (first y))
                                                            "] = "
                                                            (compile (second y))
                                                            ", ")))
                                  x)
                       (str "Mapify{"
                            (unpack t)
                            "}"))
         ;; Could preserve order here if we don't defer to HashMap compilation
         :PreHashMap (fn [x]
                       (compile (lua/HashMap (unpack x))))
         ;;; TODO
         ;; Needs to check if the head is a macro, and not compile arguments
         ;; if so, then call the macro to insert compiled code...
         :List       (fn [x]
                       ;(print (lua/tostring (first x)))
                       (let [f (specials (lua/tostring (first x)))]
                         (if f (f h)
                           (let [head (lua/eval (first x) (getenv))]
                               (if (= :Macro (type head))
                                 (compile ((get head :func) (unpack (rest x))))
                                 (str (compile (first x))
                                    "("
                                    (lua/string.sub
                                      (mapcat (fn [y]
                                                (str (compile y) ", "))
                                              (rest x))
                                      1
                                      -3)
                                    ")"))))))}]
     (if (switch (type exp))
         ((switch (type exp)) exp)
         :ERROR)))

(def lua/str str)
;; Compile one expression for testing
(lua/io.write "> ")
(let [code (str "local _env = lemma\n" (compile (lua/read (lua/FileStream (lua/io.input)))))]
	(print code)
	(lua/io.write ";=> ")
	((lua/assert (lua/loadstring code))))
