
;; TODO: Macros, etc.

(def format lua/string.format)
(def concat lua/table.concat)
(def unpack lua/Seq.lib.unpack)
(def tostring lua/tostring)
(def type   lua/type)

;; Not exactly Clojure's mapcat, since this concat isn't exactly Clojure's
;; concat... return the string concatenation of a mapped seq
(defn mapcat [f @xs]
  (str (unpack (map f ,@xs))))

;; TODO: More specials?
(def specials {
    :def (fn [xs]
           (let [ks (odds  xs)
                 vs (evens xs)]
             (mapcat (fn [k v]
                      (format "local %s = %s\n" (compile k) (compile v)))
                    ks
                    vs)))
     
     :fn  (fn [xs]
            (let [args (first xs)
                  body (rest  xs)]
              (let [funstuff ["function("
                              (lua/string.sub (mapcat (fn [arg]
                                                        (format "%s, "
                                                          (compile arg)))
                                                      args)
                                              1
                                              -3)
                              ")\n"
                              (unpack (map compile body))
                              "\nend"]]
                (lua/table.insert funstuff (- (length funstuff) 1) "return ")
                (concat funstuff))))})

(defn compile [exp]
  (let [switch {
         :number   (fn [x] (format "%d " x))
         :string   (fn [x] (format "%q " x))
         :Symbol   (fn [x] (.string x))
         :boolean  (fn [x] (if x :true :false))
         ;:False    (fn [x] :false)
         :Nil      (fn [x] :nil)
         ;; TODO: Vector needs to be Luified
         :Vector   (fn [x] (tostring x))
         ;; TODO: HashMap needs to be Luified (and/or PreHashMap?)
         :HashMap  (fn [x] (tostring x))
         ;; TODO: List needs to handle function calls in addition to specials
         :List     (fn [x]
                     ;(print (lua/tostring (first x)))
                     (let [f (specials (lua/tostring (first x)))]
                       (if f (f (rest x)))))
       }]
     (if (switch (type exp))
         ((switch (type exp)) exp))))

(print (compile '(def f (fn [x] (def y 42) y))))
(print (compile [:hi :there :buddy!]))
(print (compile {:x 42, :y 69}))
